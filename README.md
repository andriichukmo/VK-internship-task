# VK-internship-task

## О проекте

Проект реализует поиск кратчайших путей от вершинки до всех остальных в неориентированном графе, где длины всех ребер равны 1. Для решения использовался алгоритм поиска в ширину.

## Сборка и запуск
Для того, чтобы собрать решение нужно:
```bash
mkdir build
cd build
cmake ..
cmake --build .
cp ../graph.txt .
```
Чтобы его протестировать, необходимо сначала ввести входные данные в `graph.txt` в формате 
```bash
n
m
id1_1 id2_1
id1_2 id2_2
...
id1_m id2_m
v
```
где: 
- `n` - число вершин в графе
- `m` - число ребер в графе
- `id1_i` и `id2_i` - номера вершин, которые соединены `i`-м ребром
- `v` - вершинка, расстояния от которой необходимо вычислить

И затем 
```bash
./find-all-distances
```

Если входные данные соответствовали условиям, то ответ для данных входных данных окажется в файле `answer.txt` в папке сборки.

## О решении

В решении использован алгоритм поиска в ширину. Он отработает верно, так как длины всех ребер равны 1, а значит нам достаточно искать самый короткий путь по числу ребер, а не по их длине. А поиск в ширину как раз это и делает.
- временная асимптотика решения `O(n + m)`, так как 
каждую вершинку мы добавим (и удалим) очередь ровно 1 раз, а также каждое ребро будет обработано ровно дважды: по одному разу для каждой вершинки. Ну и каждое действие с ребром/вершинкой занимает `O(1)` времени.
- Памяти использовано также `O(n + m)`: мы храним только вершинки и ребра из них, а также вектор для сохранения ответов и очередь для поиска в ширину. Для графа мы используем `O(n + m)`, для очереди и вектора по `O(n)`.

